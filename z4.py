a1 = []

m1 = "1. Отсортировать массив по невозрастанию методом включения с выбором включаемого элемента справа налево"
m2 = "2. Отсортировать массив по невозрастанию методом извлечения максимального элемента, поиск максимального элемента проводить слева направо"
m3 = "3. Отсортировать массив по неубыванию методом обменов рядом стоящих элементов с фиксированным числом просмотров, направленных справа налево"
m4 = "4. Отсортировать массив по невозрастанию методом обменов рядом стоящих элементов с минимально необходимым (переменным) числом просмотров, направленных слева направо"
m5 = "5. Отсортировать массив по неубыванию методом обменов рядом стоящих элементов за один просмотр (с возвратами) справа налево"
m6 = "6. Получить упорядоченный по неубыванию массив методом слияния двух упорядоченных по невозрастанию массивов"
m7 = "7. Отсортировать массив по невозрастанию методом распределения по массиву ключей, упорядоченному по неубыванию"


# ввод данных
def main():
    # вводим массив
    print("Вводим массив")
    print("Введите количество элементов в массиве:")

    try:
        count = int(input())
        print("Теперь введите элементы массива:")
        for f in range(1, count + 1):
            l = int(input())
            a1.append(l)
    except ValueError:
        print("Ошибка ввода")
        return None
    if len(a1) < 2:
        print("Массив слишком короткий")
        return None

    # выводим массив
    print("Были введены седующие элементы массива: ")
    print(a1)

    # вводим способ сортировки
    print("Выберите метод сортировки одномерного массива: ")
    print(m1, "\n", m2, "\n", m3, "\n", m4, "\n", m5, "\n", m6, "\n", m7)
    try:
        x = int(input())
    except ValueError:
        print("Ошибка ввода")
        return None

    # проверка
    # задание требует использовать подпрограммы для каждого метода сортировки
    if x == 1:
        one()
    elif x == 2:
        two()
    elif x == 3:
        three()
    elif x == 4:
        four()
    elif x == 5:
        five()
    elif x == 6:
        six()
    elif x == 7:
        seven()
    else:
        print("Выбор неверен")
        return None


# методы сортировки
# Отсортировать массив по невозрастанию методом включения с выбором включаемого элемента справа налево
def one():
    for f in range(len(a1) - 1, -1, -1):
        for u in range(len(a1) - 1, -1, -1):
            if a1[f] < a1[u]:
                a1[f], a1[u] = a1[u], a1[f]
    # выводим массивы
    output()


# Отсортировать массив по невозрастанию методом извлечения максимального элемента, поиск максимального элемента проводить слева направо
def two():
    for f in range(0, len(a1), 1):
        temp = f
        for u in range(f + 1, len(a1), 1):
            if a1[temp] < a1[u]:
                temp = u
        a1[f], a1[temp] = a1[temp], a1[u]
    # выводим массивы
    output()


# Отсортировать массив по неубыванию методом обменов рядом стоящих элементов с фиксированным числом просмотров, направленных справа налево
def three():
    for u in range(len(a1) - 1, 0, -1):
        for f in range(len(a1) - 1, 0, -1):
            if a1[f - 1] > a1[f]:
                a1[f], a1[f - 1] = a1[f - 1], a1[f]
    # выводим массивы
    output()


# Отсортировать массив по невозрастанию методом обменов рядом стоящих элементов с минимально необходимым (переменным) числом просмотров, направленных слева направо
def four():
    # для выполнения первой интерации
    w = bool(True)
    for u in range(1, len(a1), 1):
        # если в предыдущей интерации действий не было, завершить
        if w == bool(False):
            return output()
        else:
            w = bool(False)
            for f in range(1, len(a1), 1):
                if a1[f - 1] < a1[f]:
                    a1[f], a1[f - 1] = a1[f - 1], a1[f]
                    w = bool(True)
    # выводим массивы
    output()


# Отсортировать массив по неубыванию методом обменов рядом стоящих элементов за один просмотр (с возвратами) справа налево
def five():
    left = 0
    right = len(a1) - 1
    # сравниваем элементы попарно и меняем при необходимости
    while left <= right:
        for i in range(left, right, +1):
            print(a1)
            if a1[i] > a1[i + 1]:
                a1[i], a1[i + 1] = a1[i + 1], a1[i]
        right -= 1
        for i in range(right, left, -1):
            if a1[i - 1] > a1[i]:
                a1[i], a1[i - 1] = a1[i - 1], a1[i]
        left += 1
    # выводим массивы
    output()


# Получить упорядоченный по неубыванию массив методом слияния двух упорядоченных по невозрастанию массивов
def six():
    global a1
    '''# делим массив на 2 массива
    L, R = a1[:len(a1) // 2], a1[len(a1) // 2:]
    # сортируем оба массива по невозрастанию
    L.sort(reverse=True)
    R.sort(reverse=True)'''
    mergeSort(0, len(a1) - 1)
    output()


def mergeSort(l, r):
    if l < r:
        m = (l + r) // 2

        mergeSort(l, m)
        mergeSort(m + 1, r)
        merge(l, m, r)


def merge(l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * n1
    R = [0] * n2

    for i in range(0, n1):
        L[i] = a1[l + i]

    for j in range(0, n2):
        R[j] = a1[m + 1 + j]

    i = 0
    j = 0
    k = l

    while i < n1 and j < n2:
        if L[i] <= R[j]:
            a1[k] = L[i]
            i += 1
        else:
            a1[k] = R[j]
            j += 1
        k += 1

    while i < n1:
        a1[k] = L[i]
        i += 1
        k += 1

    while j < n2:
        a1[k] = R[j]
        j += 1
        k += 1


# Отсортировать массив по невозрастанию методом распределения по массиву ключей, упорядоченному по неубыванию
def seven():
    a1.sort(reverse=True)
    end, marker, i = len(a1) - 1, 0, 0

    while i <= end:
        if a1[i] >= a1[end]:
            a1[marker], a1[i] = a1[i], a1[marker]
            marker += 1
        i += 1
    output()


# вывод данных
def output():
    print("Результат: ")
    print(a1)


# программа начинается с main
main()
